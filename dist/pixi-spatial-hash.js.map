{"version":3,"file":"pixi-spatial-hash.js","sources":["../src/SpatialHash.ts","../src/SpatialHashSystem.ts"],"sourcesContent":["import { Rectangle } from '@pixi/math';\n\nconst tempRect = new Rectangle();\n\n/**\n * 2D spatial hashing implementation that provides a mechanism to quickly searching objects intersecting\n * a rectangle.\n *\n * The spatial hash divides the world space into square \"cell\" or \"buckets\". Each display-object added is\n * tracked by which cells they intersect with.\n *\n * @memberof PIXI\n * @public\n * @see http://www.cs.ucf.edu/~jmesit/publications/scsc%202005.pdf\n */\nexport class SpatialHash<Node extends { getBounds(skipUpdate?: boolean, rect?: boolean): Rectangle }>\n{\n    cellSize: number;\n    buckets: Map<string, Set<Node>>;\n\n    /**\n     * @param cellSize - the size of the 2D cells in the hash\n     */\n    constructor(cellSize = 256)\n    {\n        this.cellSize = cellSize;\n        this.buckets = new Map();\n        this.reset();\n    }\n\n    /**\n     * Puts the display-object into the hash.\n     *\n     * @param object\n     * @param bounds - the bounds of the object. This is automatically calculated using {@code getBounds}.\n     */\n    put(object: Node, bounds = object.getBounds()): this\n    {\n        this.hashBounds(bounds, (hash) =>\n        {\n            let bucket = this.buckets.get(hash);\n\n            if (!bucket)\n            {\n                bucket = new Set();\n                this.buckets.set(hash, bucket);\n            }\n\n            bucket.add(object);\n        });\n\n        return this;\n    }\n\n    /**\n     * Removes the display-object from the hash.\n     *\n     * @param object\n     */\n    remove(object: Node): void\n    {\n        this.buckets.forEach((bucket) =>\n        {\n            bucket.delete(object);\n        });\n    }\n\n    /**\n     * Updates this spatial hash to account for any changes in the display-object's bounds. This is equivalent\n     * to removing & then adding the object again.\n     *\n     * @param object\n     * @param bounds\n     */\n    update(object: Node, bounds = object.getBounds()): void\n    {\n        this.remove(object);\n        this.put(object, bounds);\n    }\n\n    /**\n     * Searches for all the display-objects that intersect with the given rectangle bounds.\n     *\n     * @param bounds\n     */\n    search(bounds: Rectangle): Set<Node>\n    {\n        const searchResult = new Set<Node>();\n\n        this.hashBounds(bounds, (hash) =>\n        {\n            const bucket = this.buckets.get(hash);\n\n            if (bucket)\n            {\n                bucket.forEach((object) =>\n                {\n                    const objectBounds = object.getBounds(false, tempRect);\n                    const intersects = objectBounds.right >= bounds.left\n                        && objectBounds.left <= bounds.right\n                        && objectBounds.bottom >= bounds.top\n                        && objectBounds.top <= bounds.bottom;\n\n                    if (intersects)\n                    {\n                        searchResult.add(object);\n                    }\n                });\n            }\n        });\n\n        return searchResult;\n    }\n\n    /**\n     * Reset and clear the spatial hash.\n     */\n    reset(): void\n    {\n        this.buckets.forEach((value, key) =>\n        {\n            this.buckets.set(key, new Set());\n        });\n    }\n\n    private hashPoint(x: number, y: number): string\n    {\n        return `${Math.floor(x / this.cellSize)}|${Math.floor(y / this.cellSize)}`;\n    }\n\n    private hashBounds(bounds: Rectangle, callback: Function): void\n    {\n        const { cellSize } = this;\n        const sizeInv = 1 / cellSize;\n\n        const minX = Math.floor(bounds.left * sizeInv) * cellSize;\n        const minY = Math.floor(bounds.top * sizeInv) * cellSize;\n        const maxX = Math.floor(bounds.right * sizeInv) * cellSize;\n        const maxY = Math.floor(bounds.bottom * sizeInv) * cellSize;\n\n        for (let y = maxY; y >= minY; y -= cellSize)\n        {\n            for (let x = maxX; x >= minX; x -= cellSize)\n            {\n                callback(this.hashPoint(x, y));\n            }\n        }\n    }\n}\n","import { DisplayObject } from '@pixi/display';\nimport { SpatialHash } from './SpatialHash';\nimport { Renderer, System } from '@pixi/core';\nimport { Rectangle } from '@pixi/math';\nimport { Ticker } from '@pixi/ticker';\n\nconst tempRect = new Rectangle();\n\n/**\n * System plugin to the renderer for providing spatial hashing on the whole scene graph.\n *\n * ```js\n * import { SpatialHashSystem } from \"pixi-spatial-hash\";\n *\n * renderer.addSystem(SpatialHashSystem, \"spatialHash\");\n * renderer.spatialHash.addTarget(stage);\n * ```\n *\n * This system provides a shared spatial hash for the whole scene graph. It is designed to be updated on\n * each tick. By default, it will update itself before each render (on the {@code prerender} event). This\n * may cause redundant updates if you render multiple times each tick; in that case, you can custom set a\n * ticker using {@link SpatialHashSystem#setTicker}.\n *\n * ```js\n * renderer.spatialHash.setTicker(Ticker.shared);\n * ```\n *\n * You must register the \"stage\" as a hash-target in order to add it to the hash.\n *\n * @memberof PIXI.system\n * @public\n */\nexport class SpatialHashSystem extends System\n{\n    public hash2D: SpatialHash<DisplayObject>;\n    public hashTargets: Set<DisplayObject>;\n\n    public updateBeforeRender: boolean;\n    public updateTicker: Ticker;\n    public skipBoundsUpdate: boolean;\n\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        /**\n         * The spatial-hash object used by this system.\n         */\n        this.hash2D = new SpatialHash<DisplayObject>(SpatialHashSystem.SCENE_CELL_SIZE);\n\n        /**\n         * The display-object which are updated in the spatial hash on each frame, including all their direct and\n         * indirect children.\n         */\n        this.hashTargets = new Set<DisplayObject>();\n\n        /**\n         * Whether to update the spatial hash on the prerender event. You should turn this off if invoke {@code render}\n         * multiple times on each tick.\n         */\n        this.updateBeforeRender = true;\n\n        /**\n         * The ticker on which the spatial hash is being updated.\n         */\n        this.updateTicker = null;\n\n        /**\n         * Whether the bounds should be recalculated whenever {@code update} is invoked.\n         *\n         * You should turn it off if you can guarantee the bounds are correct when calling {@code update}. This\n         * can be done by adding a high-priority bounds-updating callback on the ticker before the spatial-hash\n         * update callback.\n         */\n        this.skipBoundsUpdate = false;\n    }\n\n    /**\n     * Adds the display-object to the hash-targets list. It will be updated in the spatial-hash on each tick.\n     *\n     * @param displayObject\n     */\n    addTarget(displayObject: DisplayObject): this\n    {\n        this.hashTargets.add(displayObject);\n\n        return this;\n    }\n\n    /**\n     * Removes the display-object from the hash-targets list.\n     *\n     * @param displayObject\n     */\n    removeTarget(displayObject: DisplayObject): this\n    {\n        this.hashTargets.delete(displayObject);\n\n        return this;\n    }\n\n    /**\n     * Searches for display-objects in the hash that intersect with the given rectangle bounds or\n     * that of the display-object passed.\n     *\n     * @param objectOrBounds - display-object or a rectangle\n     */\n    search(objectOrBounds: Rectangle | DisplayObject): Set<DisplayObject>\n    {\n        const bounds = objectOrBounds;\n\n        if (objectOrBounds instanceof DisplayObject || objectOrBounds.getBounds)\n        {\n            objectOrBounds = objectOrBounds.getBounds();\n        }\n\n        return this.hash2D.search(bounds);\n    }\n\n    /**\n     * Prerender event handler. This will invoke {@code update} if {@code updateBeforeRender} is enabled.\n     */\n    prerender(): void\n    {\n        if (this.updateBeforeRender)\n        {\n            this.update();\n        }\n    }\n\n    /**\n     * Sets the ticker on which the spatial hash is updated.\n     *\n     * If a ticker was already set, then the update callback is safely removed. If you want to turn off updating\n     * on each tick, then you can pass null as the ticker.\n     *\n     * {@code updateBeforeRender} is automatically disable when setting the ticker to a non-null value.\n     */\n    setTicker(ticker: Ticker): this\n    {\n        if (this.updateTicker)\n        {\n            this.updateTicker.remove(this.update);\n        }\n\n        this.updateTicker = ticker;\n\n        if (this.updateTicker)\n        {\n            this.updateBeforeRender = false;\n            this.updateTicker.add(this.update);\n        }\n\n        return this;\n    }\n\n    /**\n     * Updates the spatial-hash for the whole scene graph.\n     *\n     * If {@code updateBeforeRender} is enabled, this will be invoked on each render call.\n     *\n     * @override\n     */\n    update = (): void =>\n    {\n        const hashTargets = this.hashTargets;\n\n        this.hash2D.reset();\n\n        hashTargets.forEach((target) =>\n        {\n            // TODO: PixiJS should guarantee this before the \"prerender\" event\n            if (!this.skipBoundsUpdate)\n            {\n                // Updates the bounds of the target\n                target.getBounds(false, tempRect);\n            }\n\n            this.updateRecursive(target);\n        });\n    };\n\n    /**\n     * Puts the display-object and its subtree into the spatial hash.\n     *\n     * @param displayObject\n     */\n    protected updateRecursive(displayObject: DisplayObject): void\n    {\n        this.hash2D.put(displayObject, displayObject.getBounds(true, tempRect));\n\n        const children: Array<DisplayObject> = (displayObject as any).children;\n\n        if (!children || !children.length)\n        {\n            return;\n        }\n\n        for (let i = 0, j = children.length; i < j; i++)\n        {\n            this.updateRecursive(children[i]);\n        }\n    }\n\n    /**\n     * The 2D hashing cell size for the spatial-hash system. This must be set before the renderer is\n     * created (or the spatial-hash system is added to the renderer).\n     */\n    static SCENE_CELL_SIZE = 256;\n}\n"],"names":["tempRect","Rectangle","SpatialHash","[object Object]","cellSize","this","buckets","Map","reset","object","bounds","getBounds","hashBounds","hash","bucket","get","Set","set","add","forEach","delete","remove","put","searchResult","objectBounds","right","left","bottom","top","value","key","x","y","Math","floor","callback","sizeInv","minX","minY","maxX","hashPoint","SpatialHashSystem","System","renderer","super","hashTargets","hash2D","target","skipBoundsUpdate","updateRecursive","SCENE_CELL_SIZE","updateBeforeRender","updateTicker","displayObject","objectOrBounds","DisplayObject","search","update","ticker","children","length","i","j"],"mappings":";;;;;;;mFAEA,MAAMA,EAAW,IAAIC,kBAaRC,EAQTC,YAAYC,EAAW,KAEnBC,KAAKD,SAAWA,EAChBC,KAAKC,QAAU,IAAIC,IACnBF,KAAKG,QASTL,IAAIM,EAAcC,EAASD,EAAOE,aAe9B,OAbAN,KAAKO,WAAWF,EAASG,IAErB,IAAIC,EAAST,KAAKC,QAAQS,IAAIF,GAEzBC,IAEDA,EAAS,IAAIE,IACbX,KAAKC,QAAQW,IAAIJ,EAAMC,IAG3BA,EAAOI,IAAIT,KAGRJ,KAQXF,OAAOM,GAEHJ,KAAKC,QAAQa,QAASL,IAElBA,EAAOM,OAAOX,KAWtBN,OAAOM,EAAcC,EAASD,EAAOE,aAEjCN,KAAKgB,OAAOZ,GACZJ,KAAKiB,IAAIb,EAAQC,GAQrBP,OAAOO,GAEH,MAAMa,EAAe,IAAIP,IAwBzB,OAtBAX,KAAKO,WAAWF,EAASG,IAErB,MAAMC,EAAST,KAAKC,QAAQS,IAAIF,GAE5BC,GAEAA,EAAOK,QAASV,IAEZ,MAAMe,EAAef,EAAOE,WAAU,EAAOX,GAC1BwB,EAAaC,OAASf,EAAOgB,MACzCF,EAAaE,MAAQhB,EAAOe,OAC5BD,EAAaG,QAAUjB,EAAOkB,KAC9BJ,EAAaI,KAAOlB,EAAOiB,QAI9BJ,EAAaL,IAAIT,OAM1Bc,EAMXpB,QAEIE,KAAKC,QAAQa,QAAQ,CAACU,EAAOC,KAEzBzB,KAAKC,QAAQW,IAAIa,EAAK,IAAId,OAI1Bb,UAAU4B,EAAWC,GAEzB,MAAO,GAAGC,KAAKC,MAAMH,EAAI1B,KAAKD,aAAa6B,KAAKC,MAAMF,EAAI3B,KAAKD,YAG3DD,WAAWO,EAAmByB,GAElC,MAAM/B,SAAEA,GAAaC,KACf+B,EAAU,EAAIhC,EAEdiC,EAAOJ,KAAKC,MAAMxB,EAAOgB,KAAOU,GAAWhC,EAC3CkC,EAAOL,KAAKC,MAAMxB,EAAOkB,IAAMQ,GAAWhC,EAC1CmC,EAAON,KAAKC,MAAMxB,EAAOe,MAAQW,GAAWhC,EAGlD,IAAK,IAAI4B,EAFIC,KAAKC,MAAMxB,EAAOiB,OAASS,GAAWhC,EAEhC4B,GAAKM,EAAMN,GAAK5B,EAE/B,IAAK,IAAI2B,EAAIQ,EAAMR,GAAKM,EAAMN,GAAK3B,EAE/B+B,EAAS9B,KAAKmC,UAAUT,EAAGC,KC1I3C,MAAMhC,EAAW,IAAIC,kBA0BRwC,UAA0BC,SASnCvC,YAAYwC,GAERC,MAAMD,GAwHVtC,YAAS,KAEL,MAAMwC,EAAcxC,KAAKwC,YAEzBxC,KAAKyC,OAAOtC,QAEZqC,EAAY1B,QAAS4B,IAGZ1C,KAAK2C,kBAGND,EAAOpC,WAAU,EAAOX,GAG5BK,KAAK4C,gBAAgBF,MAlIzB1C,KAAKyC,OAAS,IAAI5C,EAA2BuC,EAAkBS,iBAM/D7C,KAAKwC,YAAc,IAAI7B,IAMvBX,KAAK8C,oBAAqB,EAK1B9C,KAAK+C,aAAe,KASpB/C,KAAK2C,kBAAmB,EAQ5B7C,UAAUkD,GAIN,OAFAhD,KAAKwC,YAAY3B,IAAImC,GAEdhD,KAQXF,aAAakD,GAIT,OAFAhD,KAAKwC,YAAYzB,OAAOiC,GAEjBhD,KASXF,OAAOmD,GAEH,MAAM5C,EAAS4C,EAOf,OALIA,aAA0BC,iBAAiBD,EAAe3C,aAE1D2C,EAAiBA,EAAe3C,aAG7BN,KAAKyC,OAAOU,OAAO9C,GAM9BP,YAEQE,KAAK8C,oBAEL9C,KAAKoD,SAYbtD,UAAUuD,GAeN,OAbIrD,KAAK+C,cAEL/C,KAAK+C,aAAa/B,OAAOhB,KAAKoD,QAGlCpD,KAAK+C,aAAeM,EAEhBrD,KAAK+C,eAEL/C,KAAK8C,oBAAqB,EAC1B9C,KAAK+C,aAAalC,IAAIb,KAAKoD,SAGxBpD,KAkCDF,gBAAgBkD,GAEtBhD,KAAKyC,OAAOxB,IAAI+B,EAAeA,EAAc1C,WAAU,EAAMX,IAE7D,MAAM2D,EAAkCN,EAAsBM,SAE9D,GAAKA,GAAaA,EAASC,OAK3B,IAAK,IAAIC,EAAI,EAAGC,EAAIH,EAASC,OAAQC,EAAIC,EAAGD,IAExCxD,KAAK4C,gBAAgBU,EAASE,YAQ/BpB,kBAAkB"}