{"version":3,"file":"pixi-spatial-hash.mjs","sources":["../src/SpatialHash.ts","../src/SpatialHashSystem.ts"],"sourcesContent":["import { Rectangle } from '@pixi/math';\n\nconst tempRect = new Rectangle();\n\n/**\n * 2D spatial hashing implementation that provides a mechanism to quickly searching objects intersecting\n * a rectangle.\n *\n * The spatial hash divides the world space into square \"cell\" or \"buckets\". Each display-object added is\n * tracked by which cells they intersect with.\n *\n * @memberof PIXI\n * @public\n * @see http://www.cs.ucf.edu/~jmesit/publications/scsc%202005.pdf\n */\nexport class SpatialHash<Node extends { getBounds(skipUpdate?: boolean, rect?: boolean): Rectangle }>\n{\n    cellSize: number;\n    buckets: Map<string, Set<Node>>;\n\n    /**\n     * @param cellSize - the size of the 2D cells in the hash\n     */\n    constructor(cellSize = 256)\n    {\n        this.cellSize = cellSize;\n        this.buckets = new Map();\n        this.reset();\n    }\n\n    /**\n     * Puts the display-object into the hash.\n     *\n     * @param object\n     * @param bounds - the bounds of the object. This is automatically calculated using {@code getBounds}.\n     */\n    put(object: Node, bounds = object.getBounds()): this\n    {\n        this.hashBounds(bounds, (hash) =>\n        {\n            let bucket = this.buckets.get(hash);\n\n            if (!bucket)\n            {\n                bucket = new Set();\n                this.buckets.set(hash, bucket);\n            }\n\n            bucket.add(object);\n        });\n\n        return this;\n    }\n\n    /**\n     * Removes the display-object from the hash.\n     *\n     * @param object\n     */\n    remove(object: Node): void\n    {\n        this.buckets.forEach((bucket) =>\n        {\n            bucket.delete(object);\n        });\n    }\n\n    /**\n     * Updates this spatial hash to account for any changes in the display-object's bounds. This is equivalent\n     * to removing & then adding the object again.\n     *\n     * @param object\n     * @param bounds\n     */\n    update(object: Node, bounds = object.getBounds()): void\n    {\n        this.remove(object);\n        this.put(object, bounds);\n    }\n\n    /**\n     * Searches for all the display-objects that intersect with the given rectangle bounds.\n     *\n     * @param bounds\n     */\n    search(bounds: Rectangle): Set<Node>\n    {\n        const searchResult = new Set<Node>();\n\n        this.hashBounds(bounds, (hash) =>\n        {\n            const bucket = this.buckets.get(hash);\n\n            if (bucket)\n            {\n                bucket.forEach((object) =>\n                {\n                    const objectBounds = object.getBounds(false, tempRect);\n                    const intersects = objectBounds.right >= bounds.left\n                        && objectBounds.left <= bounds.right\n                        && objectBounds.bottom >= bounds.top\n                        && objectBounds.top <= bounds.bottom;\n\n                    if (intersects)\n                    {\n                        searchResult.add(object);\n                    }\n                });\n            }\n        });\n\n        return searchResult;\n    }\n\n    /**\n     * Reset and clear the spatial hash.\n     */\n    reset(): void\n    {\n        this.buckets.forEach((value, key) =>\n        {\n            this.buckets.set(key, new Set());\n        });\n    }\n\n    private hashPoint(x: number, y: number): string\n    {\n        return `${Math.floor(x / this.cellSize)}|${Math.floor(y / this.cellSize)}`;\n    }\n\n    private hashBounds(bounds: Rectangle, callback: Function): void\n    {\n        const { cellSize } = this;\n        const sizeInv = 1 / cellSize;\n\n        const minX = Math.floor(bounds.left * sizeInv) * cellSize;\n        const minY = Math.floor(bounds.top * sizeInv) * cellSize;\n        const maxX = Math.floor(bounds.right * sizeInv) * cellSize;\n        const maxY = Math.floor(bounds.bottom * sizeInv) * cellSize;\n\n        for (let y = maxY; y >= minY; y -= cellSize)\n        {\n            for (let x = maxX; x >= minX; x -= cellSize)\n            {\n                callback(this.hashPoint(x, y));\n            }\n        }\n    }\n}\n","import { DisplayObject } from '@pixi/display';\nimport { SpatialHash } from './SpatialHash';\nimport { Renderer, System } from '@pixi/core';\nimport { Rectangle } from '@pixi/math';\nimport { Ticker } from '@pixi/ticker';\n\nconst tempRect = new Rectangle();\n\n/**\n * System plugin to the renderer for providing spatial hashing on the whole scene graph.\n *\n * ```js\n * import { SpatialHashSystem } from \"pixi-spatial-hash\";\n *\n * renderer.addSystem(SpatialHashSystem, \"spatialHash\");\n * renderer.spatialHash.addTarget(stage);\n * ```\n *\n * This system provides a shared spatial hash for the whole scene graph. It is designed to be updated on\n * each tick. By default, it will update itself before each render (on the {@code prerender} event). This\n * may cause redundant updates if you render multiple times each tick; in that case, you can custom set a\n * ticker using {@link SpatialHashSystem#setTicker}.\n *\n * ```js\n * renderer.spatialHash.setTicker(Ticker.shared);\n * ```\n *\n * You must register the \"stage\" as a hash-target in order to add it to the hash.\n *\n * @memberof PIXI.system\n * @public\n */\nexport class SpatialHashSystem extends System\n{\n    public hash2D: SpatialHash<DisplayObject>;\n    public hashTargets: Set<DisplayObject>;\n\n    public updateBeforeRender: boolean;\n    public updateTicker: Ticker;\n    public skipBoundsUpdate: boolean;\n\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        /**\n         * The spatial-hash object used by this system.\n         */\n        this.hash2D = new SpatialHash<DisplayObject>(SpatialHashSystem.SCENE_CELL_SIZE);\n\n        /**\n         * The display-object which are updated in the spatial hash on each frame, including all their direct and\n         * indirect children.\n         */\n        this.hashTargets = new Set<DisplayObject>();\n\n        /**\n         * Whether to update the spatial hash on the prerender event. You should turn this off if invoke {@code render}\n         * multiple times on each tick.\n         */\n        this.updateBeforeRender = true;\n\n        /**\n         * The ticker on which the spatial hash is being updated.\n         */\n        this.updateTicker = null;\n\n        /**\n         * Whether the bounds should be recalculated whenever {@code update} is invoked.\n         *\n         * You should turn it off if you can guarantee the bounds are correct when calling {@code update}. This\n         * can be done by adding a high-priority bounds-updating callback on the ticker before the spatial-hash\n         * update callback.\n         */\n        this.skipBoundsUpdate = false;\n    }\n\n    /**\n     * Adds the display-object to the hash-targets list. It will be updated in the spatial-hash on each tick.\n     *\n     * @param displayObject\n     */\n    addTarget(displayObject: DisplayObject): this\n    {\n        this.hashTargets.add(displayObject);\n\n        return this;\n    }\n\n    /**\n     * Removes the display-object from the hash-targets list.\n     *\n     * @param displayObject\n     */\n    removeTarget(displayObject: DisplayObject): this\n    {\n        this.hashTargets.delete(displayObject);\n\n        return this;\n    }\n\n    /**\n     * Searches for display-objects in the hash that intersect with the given rectangle bounds or\n     * that of the display-object passed.\n     *\n     * @param objectOrBounds - display-object or a rectangle\n     */\n    search(objectOrBounds: Rectangle | DisplayObject): Set<DisplayObject>\n    {\n        const bounds = objectOrBounds;\n\n        if (objectOrBounds instanceof DisplayObject || objectOrBounds.getBounds)\n        {\n            objectOrBounds = objectOrBounds.getBounds();\n        }\n\n        return this.hash2D.search(bounds);\n    }\n\n    /**\n     * Prerender event handler. This will invoke {@code update} if {@code updateBeforeRender} is enabled.\n     */\n    prerender(): void\n    {\n        if (this.updateBeforeRender)\n        {\n            this.update();\n        }\n    }\n\n    /**\n     * Sets the ticker on which the spatial hash is updated.\n     *\n     * If a ticker was already set, then the update callback is safely removed. If you want to turn off updating\n     * on each tick, then you can pass null as the ticker.\n     *\n     * {@code updateBeforeRender} is automatically disable when setting the ticker to a non-null value.\n     */\n    setTicker(ticker: Ticker): this\n    {\n        if (this.updateTicker)\n        {\n            this.updateTicker.remove(this.update);\n        }\n\n        this.updateTicker = ticker;\n\n        if (this.updateTicker)\n        {\n            this.updateBeforeRender = false;\n            this.updateTicker.add(this.update);\n        }\n\n        return this;\n    }\n\n    /**\n     * Updates the spatial-hash for the whole scene graph.\n     *\n     * If {@code updateBeforeRender} is enabled, this will be invoked on each render call.\n     *\n     * @override\n     */\n    update = (): void =>\n    {\n        const hashTargets = this.hashTargets;\n\n        this.hash2D.reset();\n\n        hashTargets.forEach((target) =>\n        {\n            // TODO: PixiJS should guarantee this before the \"prerender\" event\n            if (!this.skipBoundsUpdate)\n            {\n                // Updates the bounds of the target\n                target.getBounds(false, tempRect);\n            }\n\n            this.updateRecursive(target);\n        });\n    };\n\n    /**\n     * Puts the display-object and its subtree into the spatial hash.\n     *\n     * @param displayObject\n     */\n    protected updateRecursive(displayObject: DisplayObject): void\n    {\n        this.hash2D.put(displayObject, displayObject.getBounds(true, tempRect));\n\n        const children: Array<DisplayObject> = (displayObject as any).children;\n\n        if (!children || !children.length)\n        {\n            return;\n        }\n\n        for (let i = 0, j = children.length; i < j; i++)\n        {\n            this.updateRecursive(children[i]);\n        }\n    }\n\n    /**\n     * The 2D hashing cell size for the spatial-hash system. This must be set before the renderer is\n     * created (or the spatial-hash system is added to the renderer).\n     */\n    static SCENE_CELL_SIZE = 256;\n}\n"],"names":["tempRect"],"mappings":"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"}